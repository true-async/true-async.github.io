---
layout: page
lang: uk
path_key: "/motivation.html"
nav_active: motivation
permalink: /uk/motivation.html
page_title: "Мотивація"
description: "Чому PHP потрібна вбудована асинхронність"
---

## Навіщо PHP асинхронність?

`PHP` — одна з останніх великих мов, яка досі не має вбудованої
підтримки конкурентного виконання **на рівні мови**. Python отримав `asyncio`, `JavaScript` спочатку
побудований на event loop, `Go` має goroutines, `Kotlin` — coroutines. `PHP` залишається
в парадигмі «один запит — один процес», незважаючи на те що більшість
реальних застосунків витрачають основний час на очікування `I/O` (`IO Bound`).

## Проблема фрагментації

Сьогодні асинхронність у `PHP` реалізується через розширення: `Swoole`, `AMPHP`, `ReactPHP`.
Кожне з них створює **власну екосистему** з несумісними `API`,
власними драйверами баз даних, `HTTP`-клієнтами та серверами.

Це призводить до критичних проблем:

- **Дублювання коду** — кожне розширення змушене переписувати драйвери
  для `MySQL`, `PostgreSQL`, `Redis` та інших систем
- **Несумісність** — бібліотека, написана для `Swoole`, не працює з `AMPHP`,
  і навпаки
- **Обмеженість** — розширення не можуть зробити стандартні функції `PHP`
  (`file_get_contents`, `fread`, `curl_exec`) неблокуючими,
  тому що не мають доступу до ядра
- **Бар'єр входу** — розробнику потрібно вивчати окрему екосистему
  замість використання звичних інструментів

## Рішення: інтеграція в ядро

`TrueAsync` пропонує інший підхід — **асинхронність на рівні ядра PHP**.
Це означає:

### Прозорість

Наявний синхронний код працює в корутинах без змін.
`file_get_contents()`, `PDO::query()`, `curl_exec()` — усі ці функції
автоматично стають неблокуючими, коли виконуються всередині корутини.

```php
// Цей код вже працює конкурентно!
spawn(function() {
    $data = file_get_contents('https://api.example.com/users');
    // корутина призупиняється під час HTTP-запиту,
    // інші корутини продовжують працювати
});
```

### Відсутність кольорових функцій

На відміну від Python (`async def` / `await`) та JavaScript (`async` / `await`),
`TrueAsync` не вимагає маркування функцій як асинхронних.
Будь-яка функція може виконуватися в корутині — немає поділу на «синхронний»
та «асинхронний» світ.

### Єдиний стандарт

Стандартний `True Async ABI` як частина `Zend` дозволяє **будь-якому** розширенню підтримати неблокуючий `I/O`:
`MySQL`, `PostgreSQL`, `Redis`, файлові операції, сокети — все через єдиний інтерфейс.
Більше не потрібно дублювати драйвери для кожного async-фреймворку.

### Зворотна сумісність

Наявний код продовжує працювати, але тепер увесь код PHP
асинхронний за замовчуванням. Скрізь.

## PHP workload: чому це важливо саме зараз

Типовий PHP-застосунок (Laravel, Symfony, WordPress) витрачає
**70–90% часу на очікування I/O**: запити до БД, HTTP-виклики до зовнішніх API,
читання файлів. Увесь цей час CPU простоює.

З корутинами цей час використовується ефективно:

| Сценарій                      | Без корутин     | З корутинами     |
|-------------------------------|-----------------|------------------|
| 3 запити до БД по 20мс       | 60мс            | ~22мс            |
| HTTP + БД + файл              | послідовно      | паралельно       |
| 10 API-викликів               | 10 × затримка   | ~1 × затримка    |

Детальніше:
[IO-Bound vs CPU-Bound](/uk/docs/evidence/concurrency-efficiency.html),
[Статистика конкурентності](/uk/docs/evidence/real-world-statistics.html).

## Практичні сценарії

- **Web-сервери** — обробка багатьох запитів в одному процесі
  (`FrankenPHP`, `RoadRunner`)
- **API Gateway** — паралельна агрегація даних з кількох мікросервісів
- **Фонові задачі** — конкурентна обробка черг
- **Real-time** — WebSocket-сервери, чат-боти, стрімінг

## Також дивіться:

- [PHP RFC: True Async &rarr;](https://wiki.php.net/rfc/true_async){:target="_blank"}
- [RFC: Scope та структурна конкурентність](https://wiki.php.net/rfc/true_async_scope){:target="_blank"}
- [Документація TrueAsync](/uk/docs.html)
- [Інтерактивна демонстрація корутин](/uk/interactive/coroutine-demo.html)
