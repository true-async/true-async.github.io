---
layout: docs
lang: ru
path_key: "/docs/concepts/introduction.html"
nav_active: docs
permalink: /ru/docs/concepts/introduction.html
page_title: "Зачем асинхронность?"
description: "Что такое асинхронность и зачем она нужна?"
---

## Как работает традиционный PHP (FPM)

![FPM Model](../../../assets/docs/fpm_model.jpg)

Если бы PHP-серверное приложение было рестораном, то оно вероятно считалось бы элитным заведением, 
где один столик обслуживает один официант.

Каждый новый запрос к серверу обрабатывается отдельной PHP-VM, процессом или потоком, 
после чего состояние уничтожается.
Эквивалентно тому, что официант обслуживает один столик, а потом увольняется или ему стирают память.

У такой модели есть преимущество: если в PHP происходит ошибка, утечка памяти, 
забытое соединение с базой данных, то она не влияет на другие запросы. Каждый запрос изолирован.
А значит разработка проще, отладка проще, есть высокая толерантность к ошибкам.

Последние несколько лет PHP-сообщество пытается внедрить stateful модель,
когда одна PHP-VM может обслуживать несколько запросов, сохраняя состояние между ними.
Например, проект Laravel Octane, который использует Swoole или RoadRunner достигает лучшей производительности
за счет сохранения состояния между запросами.
Но это далеко не предел возможностей.

Увольнять официанта после каждого заказа слишком дорогое удовольствие.
Из-за того, что блюда готовятся на кухне медленно, официант большую часть времени ожидает.
То же самое происходит с PHP-FPM: PHP-VM простаивает.
Происходит больше переключений контекста, 
больше накладных расходов на создание и уничтожение процессов или потоков, 
больше потребление ресурсов.

```php
// Традиционный PHP-FPM
$user = file_get_contents('https://api/user/123');     // стоим и ждем 300ms
$orders = $db->query('SELECT * FROM orders');          // стоим и ждем 150ms
$balance = file_get_contents('https://api/balance');   // стоим и ждем 200ms

// Потратили: 650ms чистого ожидания
// Процессор простаивает. Память простаивает. Все ждут.
```

## Конкурентность

![Concurrency Model](../../../assets/docs/concurrency_model.jpg)

Так как кухня не может мгновенно готовить блюда,
и у официанта есть время ожидания между приготовлением,
появляется возможность обработать заказы нескольких клиентов.

Такая схема способна работать достаточно гибко:
Столик 1 сделал заказ из трёх блюд
Столик 2 сделал заказ из двух блюд
Официант приносит первое блюдо столику 1, а потом первое блюдо столику 2.
А может быть, он успел принести два блюда первому столику и одно второму. Или наоборот!

Это и есть конкурентность (concurrency): разеделение одного ресурса (`CPU`) между разными логическими потоками выполнения, 
которые называются корутинами (coroutines). 

```php
use function Async\spawn;
use function Async\await;

// Запускаем все три запроса "конкурентно"
$userTask = spawn(file_get_contents(...), 'https://api/user/123');
$ordersTask = spawn($db->query(...), 'SELECT * FROM orders');
$balanceTask = spawn(file_get_contents(...), 'https://api/balance');

// Пока один запрос ждет ответа, делаем другие!
$user = await($userTask);
$orders = await($ordersTask);
$balance = await($balanceTask);

// Потратили: 300ms (время самого медленного запроса)
```

## Конкурентность ≠ Параллелизм

Важно понимать разницу.

**Конкурентность** (concurrency) — как в `True Async`, `JavaScript`, `Python`:
- Один официант быстро переключается между столиками
- Один поток PHP переключается между задачами
- Задачи **чередуются** (interleaved), но не выполняются одновременно
- Нет race conditions — в любой момент работает только одна корутина

**Параллелизм** (parallelism) — это многопоточность (`Go`):
- Несколько официантов работают одновременно
- Несколько потоков выполняются на разных ядрах CPU
- Задачи выполняются **реально одновременно**
- Нужны мьютексы, локи, вся эта боль

## Что дальше?

Теперь вы понимаете суть. Можно копать глубже:

- [Эффективность](../evidence/concurrency-efficiency.md) — сколько корутин нужно для максимальной производительности
- [Доказательная база](../evidence/coroutines-evidence.md) — измерения, бенчмарки и исследования, подтверждающие эффективность корутин
- [Swoole на практике](../evidence/swoole-evidence.md) — реальные замеры: Appwrite +91%, IdleMMO 35M req/day, бенчмарки с БД
- [Python asyncio на практике](../evidence/python-evidence.md) — Duolingo +40%, Super.com −90% затрат, Instagram, бенчмарки uvloop
- [Корутины](coroutines.md) — как они работают под капотом
- [Scope](scope.md) — как управлять группами корутин
- [Планировщик](scheduler.md) — кто решает, какую корутину запускать
