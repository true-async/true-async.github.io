---
layout: page
lang: ru
path_key: "/motivation.html"
nav_active: motivation
permalink: /ru/motivation.html
page_title: "Мотивация"
description: "Почему PHP нужна встроенная асинхронность"
---

## Зачем PHP настоящая асинхронность?

PHP — один из последних крупных языков, который до сих пор не имеет встроенной
поддержки конкурентного выполнения. Python получил `asyncio`, JavaScript изначально
построен на event loop, Go имеет goroutines, Kotlin — coroutines. PHP остаётся
в парадигме «один запрос — один процесс», несмотря на то что большинство
реальных приложений тратят основное время на ожидание I/O.

## Проблема фрагментации

Сегодня асинхронность в PHP реализуется через расширения: Swoole, AMPHP, ReactPHP.
Каждое из них создаёт **собственную экосистему** с несовместимыми API,
собственными драйверами баз данных, HTTP-клиентами и серверами.

Это приводит к критическим проблемам:

- **Дублирование кода** — каждое расширение вынуждено переписывать драйверы
  для MySQL, PostgreSQL, Redis и других систем
- **Несовместимость** — библиотека, написанная для Swoole, не работает с AMPHP,
  и наоборот
- **Ограниченность** — расширения не могут сделать стандартные функции PHP
  (`file_get_contents`, `fread`, `curl_exec`) неблокирующими,
  потому что у них нет доступа к ядру
- **Барьер входа** — разработчику нужно изучать отдельную экосистему
  вместо использования привычных инструментов

## Решение: интеграция в ядро

TrueAsync предлагает другой подход — **асинхронность на уровне ядра PHP**.
Это означает:

### Прозрачность

Существующий синхронный код работает в корутинах без изменений.
`file_get_contents()`, `PDO::query()`, `curl_exec()` — все эти функции
автоматически становятся неблокирующими, когда выполняются внутри корутины.

```php
// Этот код уже работает конкурентно!
spawn(function() {
    $data = file_get_contents('https://api.example.com/users');
    // корутина приостанавливается во время HTTP-запроса,
    // другие корутины продолжают работать
});
```

### Отсутствие цветных функций

В отличие от Python (`async def` / `await`) и JavaScript (`async` / `await`),
TrueAsync не требует маркировки функций как асинхронных.
Любая функция может выполняться в корутине — нет разделения на «синхронный»
и «асинхронный» мир.

### Единый стандарт

Стандартный C API позволяет **любому** расширению поддержать неблокирующий I/O:
MySQL, PostgreSQL, Redis, файловые операции, сокеты — всё через единый интерфейс.
Больше не нужно дублировать драйверы для каждого async-фреймворка.

### Обратная совместимость

Существующий код продолжает работать. Асинхронность — opt-in:
она активируется только при использовании `spawn()`.
Без корутин PHP ведёт себя точно так же, как раньше.

## PHP workload: почему это важно именно сейчас

Типичное PHP-приложение (Laravel, Symfony, WordPress) тратит
**70–90% времени на ожидание I/O**: запросы к БД, HTTP-вызовы к внешним API,
чтение файлов. Всё это время CPU простаивает.

С корутинами это время используется эффективно:

| Сценарий | Без корутин | С корутинами |
|---|---|---|
| 3 запроса к БД по 20ms | 60ms | ~22ms |
| HTTP + БД + файл | последовательно | параллельно |
| 10 API-вызовов | 10 × latency | ~1 × latency |

Подробнее в документации:
[IO-Bound vs CPU-Bound](/ru/docs/evidence/concurrency-efficiency.html),
[Статистика конкурентности](/ru/docs/evidence/real-world-statistics.html).

## Практические сценарии

- **Web-серверы** — обработка множества запросов в одном процессе
  (FrankenPHP, RoadRunner)
- **API Gateway** — параллельная агрегация данных из нескольких микросервисов
- **Фоновые задачи** — конкурентная обработка очередей
- **Real-time** — WebSocket-серверы, чат-боты, стриминг

## Подробнее

Полная техническая мотивация описана в основном RFC:

[PHP RFC: True Async &rarr;](https://wiki.php.net/rfc/true_async){:target="_blank"}

Также смотрите:
- [RFC: Scope и структурная конкурентность](https://wiki.php.net/rfc/true_async_scope){:target="_blank"}
- [Документация TrueAsync](/ru/docs.html)
- [Интерактивная демонстрация корутин](/ru/interactive/coroutine-demo.html)
